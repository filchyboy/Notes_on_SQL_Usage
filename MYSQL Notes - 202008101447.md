# MySQL Notes
___

___
### Initiating Server
Local Instance of MySQL on 'malevich'

In terminal use this: `mysql -u root -p`

Password:

	>	

Then (if needed): `ALTER USER 'root'@'localhost' IDENTIFIED BY 'password'`

### Sourcing from Files

Files can be used to generate SQL queries. This promotes efficiency of code and cuts down on errors. Here's an example of one:

	CREATE TABLE dataset
		(
			data_id INT NOT NULL AUTO_INCREMENT,
			name VARCHAR(100),
			age INT,
			PRIMARY KEY(data_id)
		);
		
To initiate this file at the command line (CLI) you would type `source example_file.sql`

Note here that when writing to files you can comment code out. Here's an example:

	-- CREATE TABLE dataset
	--     (
	--         data_id INT NOT NULL AUTO_INCREMENT,
	--         name VARCHAR(100),
	--         age INT,
	--         PRIMARY KEY(data_id)
	--     );
	

### Useful Commands & Short Tutorials	
Show databases in instance: `SHOW DATABASES;`
Create databases: `CREATE DATABASE database_name;`
Delete database: `DROP DATABASE database_name;` and use this command if you wish to do this inline within a file: `DROP DATABASE IF EXISTS database_name;`

Choose specific database as working space: `USE database_name;`
Determine which database currently in use: `SELECT database();`
	
Create tables and assign datatypes to columns:

	CREATE TABLE tablename
	  (
	    column_name data_type,
	    column_name data_type
	  );
	  
Note that it's required to define lengths for strings & other datatypes: 

	  (
	    column_name VARCHAR(100),
	    column_name INT
	  );
	  
Note that in order to require data in each field you must use `NOT NULL`: 

	  (
	    column_name VARCHAR(100) NOT NULL,
	    column_name INT NOT NULL
	  );
	  
Note that in order to allow for default values in each field you must use `DEFAULT`: 

	  (
	    column_name VARCHAR(100) NOT NULL DEFAULT 'default_value',
	    column_name INT NOT NULL DEFAULT 10
	  );
	  
Discover which tables are present in database: `SHOW TABLES;`
	
Explore which columns, or features, are available within a table: `SHOW COLUMNS IN tablename;` In this context you can use `DESC tablename;` to get the same result.

To delete a table from the database: `DROP TABLE tablename;`

To insert records into a table: `INSERT INTO tablename (column_name, column_name) VALUES(value, value);` or to insert multiple rows use `VALUES(value, value), (value, value)` etc.

Inserting records which contain quote marks receive special attention. You can either escape the quotes with a backslash: `"This text has \"quotes\" in it"` or `'This text has \'quotes\' in it'` or you can alternate single and double quotes: `"This text has 'quotes' in it"` or `'This text has "quotes" in it'`.

To view all data in all columns within a table: `SELECT * FROM tablename;` or for all data within specific columns: `SELECT column_name FROM tablename;` or `SELECT column_name_1, column_name_2 FROM tablename;`

When working within the shell if errors are introduced with things like VARCHAR line length or datatype issues you use `SHOW WARNINGS;` to read info from the interpretor. Also be aware that such warnings will sometimes produce bad data so if there is a warning but the insertion worked it may have inserted bad data.

The primary key is the unique identifier per row. They are assigned by column. So this is useful to be assigned upon creation of the table, like this:

		CREATE TABLE tablename
	  (
	  	column_name_id INT NOT NULL AUTO_INCREMENT,
		column_name_1 data_type_1,
		column_name_2 data_type_2,
		PRIMARY KEY (column_name_id)
	  );
	  
Please note you can also define the primary key on the same line of the column declaration, like this `column_name_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,` and then leave out this `PRIMARY KEY (column_name_id)`. Both work.

Note that `AUTO_INCREMENT` does just what it says which is to force the database to automatically advance the primary key so that you do not have to do that when inserting data.

In order to retrieve specific data within a specific column & row use the `WHERE` command. For instance, `SELECT column_name FROM tablename WHERE variable=target;` Note that this is not case sensitive so `variable=target;` should work to find the same data that `variable=TARGET;` will find.

In order to simplify queries employ aliases. Aliases can be generated as follows: `SELECT column_name AS name FROM tablename WHERE variable=target;`. The results will temporarily render `column_name` as `name` which can be useful during more complicated queries such as a `JOIN`.

Changing data within fields requires use of `UPDATE` in conjunction with `SET` such as : `UPDATE tablename SET column_name='new' WHERE column_name='old';`

Of note here, always do the equivilent `SELECT` & `WHERE` query before you do an `UPDATE` on any data to ensure you are making the correct changes.

The same schema as above for `SELECT` & `WHERE` applies to `DELETE`.  So to delete: `DELETE tablename WHERE column_name='target';` Once again always perform the associated `SELECT` prior to ensure you are not deleting the wrong field or row.

To remove all the data from a table but not delete the table itself use `DELETE FROM tablename`. Again make sure this is what you actually wish to do. The data  cannot be retrieved once it's been deleted.

Here's some [useful string functions](https://dev.mysql.com/doc/refman/8.0/en/string-functions.html) from the mySQL documentation.

To concatenate strings it's simply `SELECT CONCAT(column_name_1, column_name_2) AS concat_column_name FROM tablename;`. This can be modified by adding strings within the concatenation such as `SELECT CONCAT(column_name_1, ' ', column_name_2) AS concat_column_name FROM tablename;` or `SELECT CONCAT(column_name_1, ' and ', column_name_2) AS concat_column_name FROM tablename;` Note that `CONCAT` has a useful cousin in `CONCAT_WS` (which stands for 'with separator') that is used like this: `SELECT CONCAT_WS(' - ', column_name_1, column_name_2) FROM tablename;` where the `' - '` is the separator chosen. You could use `','`, etc.

If you would like to take slices of strings, or substrings, you use the following commands `SELECT SUBSTRING('Hello World', 1, 5) FROM table_name;` with the first integer representing the starting point for the slice and the second integer representing the ending point of the slice. These slices can be called from the end by using negative integers, for instance `SELECT SUBSTRING('Hello World', -5) FROM table_name;` The same use of `AS` as above can be done. Renaming slices is quite useful and will help alleviate confusion and messy appearing code. `SUBSTRINGS` can be used in conjunction with `CONCAT`. This is accomplished through the use of nesting string functions. For instance: 

	SELECT CONCAT
    (
        SUBSTRING('string of thieves', 1, 10),
        '...'
    )
	FROM table_name;
	
To replace strings or length of strings use `REPLACE`. Keep in mind that this is case sensitive so `R` does not replace `r` in strings when using this command. So to use this it would look like this: `SELECT REPLACE('string to be edited', 'string to be replaced', 'replacement_string') FROM table_name;` And once again this can be nested within other string functions as before. Here's an example:

	SELECT
		SUBSTRING(REPLACE(column_name, 'R', 'r'), 1, 5) AS 'new column'
	FROM table_name;
	
Please note that `REPLACE`, as well as the other string functions, only change the query output, they don't affect the actual data in the database. In order to change the data on the database you must `UPDATE` the output back into the database or write it to another location.

Another useful string function is `REVERSE`. Usage is similar to others mentioned: `SELECT REVERSE('string to be reversed') FROM table_name;` Note this function also can be used in conjunction with others such as `REPLACE`, `SUBSTRING`, etc.

`CHAR_LENGTH` is used to count the length of a string of characters. `SELECT CHAR_LENGTH(column_name) AS length FROM table_name;`

Next we come to `UPPER` & `LOWER` as in: `SELECT UPPER(column_name) FROM table_name;`, etc.
	  


`set sql_mode='';`



	
	
## Links
[[SQL Curriculum - 2020081414]]
[[Datatypes in SQL - 202008101549]]
