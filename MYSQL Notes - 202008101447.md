# MySQL Notes
___

___
### Initiating Server
Local Instance of MySQL on 'malevich'

In terminal use this: `mysql -u root -p`

Password:

	>	

Then (if needed): `ALTER USER 'root'@'localhost' IDENTIFIED BY 'password'`

### Sourcing from Files

Files can be used to generate SQL queries. This promotes efficiency of code and cuts down on errors. Here's an example of one:

	CREATE TABLE dataset
		(
			data_id INT NOT NULL AUTO_INCREMENT,
			name VARCHAR(100),
			age INT,
			PRIMARY KEY(data_id)
		);
		
To initiate this file at the command line (CLI) you would type `source example_file.sql`

Note here that when writing to files you can comment code out. Here's an example:

	-- CREATE TABLE dataset
	--     (
	--         data_id INT NOT NULL AUTO_INCREMENT,
	--         name VARCHAR(100),
	--         age INT,
	--         PRIMARY KEY(data_id)
	--     );
	

## Useful Commands & Short Tutorials

### Creating a Database & Table(s)
Show databases in instance: `SHOW DATABASES;`
Create databases: `CREATE DATABASE database_name;`
Delete database: `DROP DATABASE database_name;` and use this command if you wish to do this inline within a file: `DROP DATABASE IF EXISTS database_name;`

Choose specific database as working space: `USE database_name;`
Determine which database currently in use: `SELECT database();`
	
Create tables and assign data types to columns:

	CREATE TABLE tablename
	  (
	    column_name data_type,
	    column_name data_type
	  );
	  
Note that it's required to define possible lengths for strings & other data types: 

	  (
	    column_name VARCHAR(100),
	    column_name INT
	  );
	  
Or maybe a specific length as in `CHAR`:

	  (
	    column_name CHAR(10),
	    column_name INT
	  );
	  
### Data Types
	  
Here's some further documentation about [data types & their usage within SQL, or in this case - MySQL](https://dev.mysql.com/doc/refman/8.0/en/data-types.html). Note for instance here in my use of `CHAR` data type that because it is a fixed specific length that its associated memory usage is consistent and thus any usage of `CHAR` is going to be computationally lighter than the same usage of `VARCHAR`. So if you know that a string will always be of a fixed length it makes more sense to use `CHAR` but if a string may be of varying sizes then use `VARCHAR` and take the computational hit. 

Another useful data-type is `DECIMAL(5,3)` where the number to the right determines how many digits after the decimal are allowed and the subsequent rounding that comes with that. So to drive the point home further the above would be written as `DECIMAL(5,2)` if the goal is to represent currency (or price).

Floating point versus fixed point? What's that & why does it matter? Well according to the [Analog Devices Educational Library](https://www.analog.com/en/education/education-library/articles/fixed-point-vs-floating-point-dsp.html):

> The term ‘fixed point’ refers to the corresponding manner in which numbers are represented, with a fixed number of digits after, and sometimes before, the decimal point. With floating-point representation, the placement of the decimal point can ‘float’ relative to the significant digits of the number....floating point can support a much wider range of values than fixed point, with the ability to represent very small numbers and very large numbers.

This is useful to understand because `DECIMAL` as described above is a fixed point representation whereas `FLOAT` or `DOUBLE` calculations are floating-point representations of numbers. `FLOAT` & `DOUBLE` store larger numbers with a more efficient memory usage with the cost of being esitmates versus `DECIMALS` which are highly precise but require far more memory to manage. `FLOAT` is said to be accurate up to about ~7 places while `DOUBLE` is accurate up to about ~15 places. Short answer on all of this is always use `DECIMAL` unless you are positive that precision doesn't matter.

### Dates & Times

`DATE` YYYY-MM-DD `TIME`HH:MM:SS `DATETIME` YYYY-MM-DD HH:MM:SS are formatted date/time data from within SQL that use the following commands to create: `CURDATE()`, `CURTIME()`, `NOW()`. Here's a handy list of [date/time functions recognized my the MySQL database](https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html). There's lots of great stuff and capabilities contained in that documentation. I'll not go down that path too much here. Here's but one example: `SELECT CONCAT(MONTHNAME(birthdate), ' ', DAY(birthdate), ' ', YEAR(birthdate)) FROM people;`

### More on Tables

Note that in order to require data in each field you must use `NOT NULL`: 

	  (
	    column_name VARCHAR(100) NOT NULL,
	    column_name INT NOT NULL
	  );
	  
Note that in order to allow for default values in each field you must use `DEFAULT`: 

	  (
	    column_name VARCHAR(100) NOT NULL DEFAULT 'default_value',
	    column_name INT NOT NULL DEFAULT 10
	  );
	  
Discover which tables are present in database: `SHOW TABLES;`
	
Explore which columns, or features, are available within a table: `SHOW COLUMNS IN tablename;` In this context you can use `DESC tablename;` to get the same result.

To delete a table from the database: `DROP TABLE tablename;`

### Inserting Records into a Table

To insert records into a table: `INSERT INTO tablename (column_name, column_name) VALUES(value, value);` or to insert multiple rows use `VALUES(value, value), (value, value)` etc.

Inserting records which contain quote marks receive special attention. You can either escape the quotes with a backslash: `"This text has \"quotes\" in it"` or `'This text has \'quotes\' in it'` or you can alternate single and double quotes: `"This text has 'quotes' in it"` or `'This text has "quotes" in it'`.

### Selecting Records from a Table

To view all data in all columns within a table: `SELECT * FROM tablename;` or for all data within specific columns: `SELECT column_name FROM tablename;` or `SELECT column_name_1, column_name_2 FROM tablename;`

### Warnings & Primary Keys

When working within the shell if errors are introduced with things like VARCHAR line length or datatype issues you use `SHOW WARNINGS;` to read info from the interpretor. Also be aware that such warnings will sometimes produce bad data so if there is a warning but the insertion worked it may have inserted bad data.

The primary key is the unique identifier per row. They are assigned by column. So this is useful to be assigned upon creation of the table, like this:

		CREATE TABLE tablename
	  (
	  	column_name_id INT NOT NULL AUTO_INCREMENT,
		column_name_1 data_type_1,
		column_name_2 data_type_2,
		PRIMARY KEY (column_name_id)
	  );
	  
Please note you can also define the primary key on the same line of the column declaration, like this `column_name_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,` and then leave out this `PRIMARY KEY (column_name_id)`. Both work.

Note that `AUTO_INCREMENT` does just what it says which is to force the database to automatically advance the primary key so that you do not have to do that when inserting data.

### Selecting for Specific Data Using Where

In order to retrieve specific data within a specific column & row use the `WHERE` command. For instance, `SELECT column_name FROM tablename WHERE variable=target;` Note that this is not case sensitive so `variable=target;` should work to find the same data that `variable=TARGET;` will find.

### Ease of Use with Aliases

In order to simplify queries employ aliases. Aliases can be generated as follows: `SELECT column_name AS name FROM tablename WHERE variable=target;`. The results will temporarily render `column_name` as `name` which can be useful during more complicated queries such as a `JOIN`.

Changing data within fields requires use of `UPDATE` in conjunction with `SET` such as : `UPDATE tablename SET column_name='new' WHERE column_name='old';`

Of note here, always do the equivilent `SELECT` & `WHERE` query before you do an `UPDATE` on any data to ensure you are making the correct changes.

The same schema as above for `SELECT` & `WHERE` applies to `DELETE`.  So to delete: `DELETE tablename WHERE column_name='target';` Once again always perform the associated `SELECT` prior to ensure you are not deleting the wrong field or row.

To remove all the data from a table but not delete the table itself use `DELETE FROM tablename`. Again make sure this is what you actually wish to do. The data  cannot be retrieved once it's been deleted.

Here's some [useful string functions](https://dev.mysql.com/doc/refman/8.0/en/string-functions.html) from the mySQL documentation.

To concatenate strings it's simply `SELECT CONCAT(column_name_1, column_name_2) AS concat_column_name FROM tablename;`. This can be modified by adding strings within the concatenation such as `SELECT CONCAT(column_name_1, ' ', column_name_2) AS concat_column_name FROM tablename;` or `SELECT CONCAT(column_name_1, ' and ', column_name_2) AS concat_column_name FROM tablename;` Note that `CONCAT` has a useful cousin in `CONCAT_WS` (which stands for 'with separator') that is used like this: `SELECT CONCAT_WS(' - ', column_name_1, column_name_2) FROM tablename;` where the `' - '` is the separator chosen. You could use `','`, etc.

If you would like to take slices of strings, or substrings, you use the following commands `SELECT SUBSTRING('Hello World', 1, 5) FROM table_name;` with the first integer representing the starting point for the slice and the second integer representing the ending point of the slice. These slices can be called from the end by using negative integers, for instance `SELECT SUBSTRING('Hello World', -5) FROM table_name;` The same use of `AS` as above can be done. Renaming slices is quite useful and will help alleviate confusion and messy appearing code. `SUBSTRINGS` can be used in conjunction with `CONCAT`. This is accomplished through the use of nesting string functions. For instance: 

	SELECT CONCAT
    (
        SUBSTRING('string of thieves', 1, 10),
        '...'
    )
	FROM table_name;
	
To replace strings or length of strings use `REPLACE`. Keep in mind that this is case sensitive so `R` does not replace `r` in strings when using this command. So to use this it would look like this: `SELECT REPLACE('string to be edited', 'string to be replaced', 'replacement_string') FROM table_name;` And once again this can be nested within other string functions as before. Here's an example:

	SELECT
		SUBSTRING(REPLACE(column_name, 'R', 'r'), 1, 5) AS 'new column'
	FROM table_name;
	
Please note that `REPLACE`, as well as the other string functions, only change the query output, they don't affect the actual data in the database. In order to change the data on the database you must `UPDATE` the output back into the database or write it to another location.

Another useful string function is `REVERSE`. Usage is similar to others mentioned: `SELECT REVERSE('string to be reversed') FROM table_name;` Note this function also can be used in conjunction with others such as `REPLACE`, `SUBSTRING`, etc.

`CHAR_LENGTH` is used to count the length of a string of characters. `SELECT CHAR_LENGTH(column_name) AS length FROM table_name;` Note that `CHAR_LENGTH` starts at the integer 1. So 'hello' consists of `CHAR_LENGTH` 1-5 and not 0-4.

Next we come to `UPPER` & `LOWER` as in: `SELECT UPPER(column_name) FROM table_name;`, etc. These can of course be used in conjunction with the other string functions listed above as described in previous examples.

Next we come to `DISTINCT` which operates similarly to `set` in python by taking a list of items which may contain duplicates and removing the duplicates so that only the distinct elements of the list are output. It's used like this: `SELECT DISTINCT column_name FROM table_name;`. Please note this can be used across multiple columns so `SELECT DISTINCT column_name_1, column_name_2 FROM table_name;` could work as well depending on the circumstances.

`ORDER BY` allows for the sorting of output from queries. Usage is as follows: `SELECT column_name FROM table_name ORDER BY column_name;` Note that default on `ORDER BY` is ascending, or A-Z. To change this to descending you would: `SELECT column_name FROM table_name ORDER BY column_name DESC;` Also of interest is that you can select multiple columns and then sort by the number of the perferred column rather than just the name: `SELECT column_name_1, column_name_2 FROM table_name ORDER BY 2 DESC;` where the `ORDER BY` is actually `column_name_2` as it is the second column in the `SELECT`. It's also possible to sort by 2 columns. So for example: `SELECT column_name_1, column_name_2 FROM table_name ORDER BY column_name_2, column_name_1 DESC;` which would clear up any alphabetizing in the first column after the second.

`LIMIT` is a useful way to select a portion of a sort. It can be done for a full select but far more useful with sorts. For example: `SELECT column_name FROM table_name ORDER BY column_name DESC LIMIT 10;` Note that `LIMIT` can be used to select from within a range, like this (starting point in first space, length of list in second space): `SELECT column_name FROM table_name ORDER BY column_name DESC LIMIT 0, 10;` where the `LIMIT 0, 10;`refers to the 0th cell to the 9th cell in the column. So this, `LIMIT 7, 2;`  for instance would select for the 6th through 8th cell in the column. SQL is rather klunky in handling ranges within the `LIMIT` string function. The docs use this `SELECT * FROM tbl LIMIT 1,18446744073709551615;` as an example of how to select all of the column length no matter how long it is.

`LIKE` is another useful command which allows for pattern matching at a simple level. The following code is an example: `SELECT column_name_1, column_name_2 FROM table_name WHERE column_name_1 LIKE '%tom%';`. The `%` characters are called wildcards. This formulation has a wildcard at both the front and back of the string being matched against. The wildcards can be in front of the string or after the string. If presented like this `tom%` the string must begin with `tom`. If presented like this `%tom` the string must end with `tom`. Further wildcards can be generated through underscores like so: `SELECT column_name_1, column_name_2 FROM table_name WHERE column_name_1 LIKE '__';` which creates a query searching for a string which is 2 characters long. Looking for 4 characters in length? That would be `SELECT column_name_1, column_name_2 FROM table_name WHERE column_name_1 LIKE '____';` Please note that through the use of the special characters it's important to be able to escape these characters. So a search for this `%` would be `%\%%` and a search for this `_` would be `_\__`.

`COUNT` is another useful function which allows for enumerating members of a group. `SELECT COUNT(*) FROM table_name;`, or `SELECT COUNT(column_name) FROM table_name;`, or `SELECT COUNT(DISTINCT column_name) FROM table_name;`, or `SELECT COUNT(*) FROM table_name WHERE column_name LIKE '%string%';` are a few examples of ways it can be used.

`GROUP BY` summarizes or aggregates identical data into single rows. `SELECT column_name_1, column_name_2 FROM table_name GROUP BY column_name_1;` is a first stab at usage but it becomes useful when combined with `COUNT`. `SELECT column_name_1, COUNT(*) FROM table_name GROUP BY column_name_1;`. As before this construction can be used in conjunction with all of the previous codes.

`MIN` & `MAX` can be used to find edges in counts or integers. For instance, `SELECT MIN(column_name) FROM table_name;` or `SELECT MAX(column_name) FROM table_name;` Note that the `MIN` or `MAX` may end up disconnected from other fields so it's important to maintain a connection to other columns by using modifcations to this code. For instance, `SELECT * FROM table_name WHERE column_name = (SELECT MIN(column_name) FROM table_name);`. This is a subquery. A subquery is run prior to the primary `SELECT`so it creates a longer computational run time for the query. This fixes the issue of the `MIN` or `MAX` losing context but at a cost. Another method could be to use this: `SELECT * FROM table_name ORDER BY column_name DESC LIMIT 1;` as a replacement for `MAX` which maintains context while also being lighter computationally. `MIN` & `MAX` can be combined once again with other instructions. It works well in conjunction with `GROUP BY` as in this example: `SELECT column_name_1, column_name_2, MIN(column_name_3) FROM table_name GROUP BY column_name_1, column_name_2;`

Another potentially useful command is `SUM`. Here's a couple of examples: `SELECT SUM(column_name) FROM table_name;` , or `SELECT column_name_1, column_name_2, SUM(column_name_3) FROM table_name GROUP BY column_name_1, column_name_2;`. This is all self-explanatory.

`AVG` is also self-explanatory. Here's a quick example: `SELECT AVG(column_name) FROM table_name;`. This command can also be used in conjunction with many, if not all, of the previous commands. Be sure to check your work to ensure you are actually getting the results you expect before you rely upon these average results.


	  


`set sql_mode='';`



	
	
## Links
[[SQL Curriculum - 2020081414]]
[[Datatypes in SQL - 202008101549]]
